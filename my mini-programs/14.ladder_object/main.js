/*
Это ladder (лестница) – объект, который позволяет подниматься вверх и спускаться:

let ladder = {
    step: 0,
    up() {
        this.step++;
    },
    down() {
        this.step--;
    },
    showStep: function() { // показывает текущую ступеньку
        alert( this.step );
    }
};

Теперь, если нам нужно сделать несколько последовательных вызовов, мы можем выполнить это так:
ladder.up();
ladder.up();
ladder.down();
ladder.showStep(); // 1

Измените код методов up, down и showStep таким образом, чтобы их вызов можно было сделать по цепочке, например так:
ladder.up().up().down().showStep(); // 1
 */

let ladder = {
    step: 0,
    up() {
        this.step++;
        return this;    // Решением является возврат самого объекта в каждом методе.
    },
    down() {
        this.step--;
        return this;
    },
    showStep: function() { // показывает текущую ступеньку
        alert( this.step );
        return this;
    }
};

ladder.up().up().down().down().down().down().showStep();

/*
return this  возвращает текущий объект целиком. Смотрим на выражение
ladder.up().up().down().showStep().
Точка возвращает метод свойства справа объекта слева. Сначала вызывается метод ladder.up().
Результатом этой функции будет увеличение свойства step на один, после чего функция вернет полную структуру объекта.
Затем вызывается функция .up(). В данном случае слева от up(), до точки, будет стоять структура объекта
(то, что вернула прошлая функция), или, другими словами, эквивалентное структуре значение,
то есть название объекта ladder. В итоге получается, что после выполнения первой функции up(),
мы имеем вторую функцию up(), вид которой в js расценивается как вызов ladder.up(). Если прямо вообще проще говоря,
то после выполнения каждой функции return this позволяет "удалить" из цепочки ladder.up().up().down().showStep()
последнюю вызванную функцию и перейти к следующей. При этом, рассматривается только текущий вызов, ибо до тех,
что находятся после язык еще не дошел.
 */